---
description: 网络常见面试题记录。
id: intro-network
title: 网络常见面试题
tags:
    - network
    - Code
    - interviews
    - 前端面试
    - Front-end

sidebar_position: 1
---

### 讲一下 HTTP 状态码

-   100 Continue：表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略。
-   101 Switching Protocols：表示服务端应客户端升级协议的请求（切换协议）
-   200 OK：表示请求成功，当前 200 状态码的响应可以被缓存
-   201 Created：表示请求被成功处理，并创建了新资源
-   202 Accepted：表示服务器接收到请求信息，但未进行处理。
-   204 Not Content：表示目前请求成功，但客户端不需要更新页面。（put）
-   301 永久重定向：浏览器会把重定向后的地址缓存起来，将来用户再次访问原始地址时，直接引导用户访问新地址（域名跳转）
-   302 临时重定向：浏览器会引导用户进入新地址，但不会缓存原始地址，下一次用户访问源地址时，浏览器仍然要请求原地址的服务器（临时转移）
-   303 其他重定向：表示重定向链接请求指向的不是新上传的资源，而是另一个页面（消息确认页面或上传进度页面）
-   304 资源未修改，服务器通过该状态码告诉客户端，请求的资源和过去一样，并没有任何变化，建议自行使用过去的缓存。通常，304 状态码的响应中，服务器不会附带任何的响应体。
-   307 临时重定向：类似 302，区别在于能够确保请求方法和消息主体不会发生改变。
-   308 永久重定向：类似 301，区别在于能够确保请求方法和消息主体不会发生改变。
-   400 Bad Request：表示语法无效，服务器无法理解该请求。
-   401 Unauthorized：表示缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。（权限未认证）
-   403 Forbidden：表示永久验证过身份凭证，但是在某项资源操作上没有权限。具有永久性，与应用程序逻辑相关。
-   403 不允许访问。服务器通过该状态码告诉客户端，这个资源目前不允许访问。这种状态码通常出现在权限不足的情况下。
-   404 Not Found：说明服务器端无法找到所请求的资源。
-   405 Method Not Allowed：表示服务器禁用使用当前 HTTP 方法的请求。（GET 与 HEAD 两个方法无法禁用）
-   406 Not Acceptable：表示服务器端不支持 Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的。
-   409 Conflict：表示请求与服务器目标资源的当前状态相互冲突。
-   410 Gone：表示请求内容已在发服务器上不存在，同时是永久性丢失。（如果不清楚是否为永久或临时的丢失，应该使用 404）
-   413 Plyload Too Layge：表示请求主体的大小超过了服务器愿意或有能力处理的限度，服务器可能会（may）关闭连接以防止客户端继续发送该请求。（超出资源大小限制）
-   500 Internal Server Error：表示所请求的服务器遇到意外的情况并阻止其执行请求。（服务器错误）
-   501 Not Implemented：表示 request header 里的 method 或 Content-\* 时不被服务器支持，无法被处理。（请求头不支持）
-   502 Bad Gateway：表示作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。（网关错误）
-   503 Service Unavailable：表示服务器尚未处于可以接受请求的状态。（服务器停机或维护）
-   504 Gateway Timeout：表示网关或者代理的服务器无法在规定的时间内获得想要的响应。（网关超时）

### GET 与 POST 的区别

-   从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
-   从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
-   从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
-   从**幂等性**的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
-   从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

### 强缓存和协商缓存

强缓存和协商缓存都是 HTTP 协议中常用的缓存机制，主要是为了提高网络传输效率和用户访问体验。
简单来说，强缓存是单方面由服务器控制的缓存方式，内容直接从缓存返回，速度更快但是可能返回过期数据。
协商缓存需要客户端和服务器协商一致，相对稍微慢一点但数据更准确实时，不会出现过期内容。

### Http 状态码 301 和 302 的应用场景分别是什么

301 表示永久重定向，302 表示临时重定向。

如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。

因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页

### 介绍下  `http1.0`、`http1.1`、`http2.0`  协议的区别？

首先是 http1.0，它的特点是每次请求完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这种方式有两个问题，分别是无法复用链接与会造成对头阻塞。

然后是 http1.1，它在 http1.0 的基础上做了 4 个优化，分别是长连接、管道化、缓存与断点续传。

最后是 http2.0 进一步优化了传输效率，比如将传输信息分为更小的二进制分帧
多路复用、头部压缩以及服务器推送。

### HTTP1.1 是如何复用 tcp 连接的？

客户端请求服务器时，通过请求行告诉服务器使用的协议是 http1.1，同时在请求头中附带 connection:keep-alive（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的 TCP 连接。

这样做的好处是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于 http1.1 不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在 http2.0 出现之前，实际项目中往往把静态资源，比如图片，分发到不同域名下的资源服务器，以便实现真正的并行传输。

### 为什么 HTTP1.1 不能实现多路复用

因为 http1.1 没有实现二进制分帧，不是通过二进制传输，而是通过文本进行传输。
由于没有流的概念，接收端在接收后无法区分多个响应分别对应的请求，所有无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 简单讲解一下 http2 的多路复用

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### 介绍 HTTP 握手过程

-   客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息
-   服务器响应公钥和服务器证书
-   客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器
-   服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪
-   客户端使用会话密钥解密消息，知道了服务器已经准备就绪。
-   后续客户端和服务器使用会话密钥加密信息传递消息

### HTTPS 握手过程中，客户端如何验证证书的合法性

1.  校验证书的颁发机构是否受客户端信任。
2.  通过 CRL 或 OCSP 的方式校验证书是否被吊销。
3.  对比系统时间，校验证书是否在有效期内。
4.  通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。

### A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态

如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可） 因为 B 会在重启之后进入 tcp 状态机的 listen 状态，只要当 a 重新发送一个数据包（无论是 syn 包或者是应用数据），b 端应该会主动发送一个带 rst 位的重置包来进行连接重置，所以 a 应该在 syn_sent 状态

### 讲一下 TCP/UDP 跟 HTTP 的关系

-   TCP(传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通讯协议。它通过三次握手建立连接,然后传输数据,最后四次挥手关闭连接。TCP 会处理数据包的校验和重发,保证数据完整可靠。
-   UDP(用户数据报协议)是无连接的、不可靠的、基于数据报的传输层协议。它不需要建立和 terminiate 连接,直接可以发送数据包。但 UDP 不对数据的准确性或顺序性作保证。
-   HTTP 是一种应用层的面向对象的协议,常见应用是万维网数据通信。它基于 TCP 协议,用于客户端和服务器之间的数据传输。

总结：

-   HTTP 处于应用层,基于 TCP 实现客户端和服务端应用程序的通信
-   HTTP 依赖 TCP/IP 协议完成数据的可靠传输它们的关系可以简单地理解为:TCP/UDP 是 HTTP 数据传输的基石,HTTP 通过使用 TCP/UDP 协议来传送其应用数据。

### TCP 与 UDP 的区别

面向连接的协议,需要在发送数据前建立连接  
传输可靠,通过顺序号和确认应答来确保数据的顺序接收和无差错  
传输的数据是有流控的,可以控制传输的速度,避免接收端的数据来不及处理

面向无连接的协议,在发送数据之前不需要建立连接  
传输不可靠,交付不保证和数据顺序不保证  
没有流控,发送端只管发送,接受端来不及处理的丢弃  
传输快,没有复杂的控制和确认过程,直接发送数据

总结来说,TCP 和 UDP 的主要区别在于:

1. TCP 面向连接,UDP 无连接
2. TCP 传输可靠,UDP 传输不可靠
3. TCP 有流量控制,UDP 没有流量控制
4. TCP 传输慢,UDP 传输快

### 谈谈你对 TCP 三次握手和四次挥手的理解

TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：

-   首先服务器进入监听状态，然后即可处理连接
-   第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。
-   第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。
-   第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。
-   最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成

当需要关闭连接时，需要进行四次挥手才能关闭

1.  Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
2.  Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
3.  Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
4.  Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
5.  Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
6.  Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。

### 描述一下 websocket 协议

websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。

首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用 ws:开头的地址，请求头中要分别加入 upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version 标记

然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含 Switching Protocols，同时响应头中包含 upgrade、connection、Sec-WebSocket-Accept 标记

当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。

### webSocket 与传统的 http 有什么优势

当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:

第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据

第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。

无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。

**websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。**

### 介绍下如何实现 token 加密

以最常见的 token 格式 jwt 为例, token 分为三段，分别是 header、payload、signature。 其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。

token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。

所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。

---

### cookie 和 token 都存放在 header 中，为什么不会劫持 token？

由于浏览器会自动发送 cookie 到服务器，因此攻击者可以利用这种特点进行 csrf 攻击。

而通常 token 是不放到 cookie 中的，需要浏览器端使用 JS 自行保存到 localstorage 中，在请求时也需要手动的加入到请求头中，因此不容易引发 csrf 攻击。

---

### 你知道什么是 XSS 吗?

XSS 称为跨站脚本攻击，它允许恶意脚本被注入到网页中。这可能会被用来窃取 cookie、会话和密码，也可以重定向用户到其他页面，以及改变网页内容。

XSS 攻击的主要原理是注入恶意脚本(通常是 JavaScript)到受信任的网页中。当用户浏览这个网页时，恶意脚本会在用户浏览器中执行，从而达到攻击者的目的。

---

### 你知道什么是 CSP 吗?

CSP 是内容安全策略(Content Security Policy)的缩写，是一种用来防范 XSS(跨站脚本攻击)和数据注入攻击的安全标准。**它通过限制可以被加载的资源来防御这些攻击。**

具体来说，CSP 允许我们通过 HTTP 头指令告诉浏览器，哪些外部资源(脚本、样式表、iframes 等)是允许被加载的。浏览器会根据这些指令来决定是否加载某个资源。所以通过合理的 CSP 配置，我们可以只允许加载可信的资源，从而防止 XSS 等攻击。

### 如何解决跨域？

1.  使用 JSONP

这是一种古老的解决跨域问题的思路。在需要跨域请求时，事先准备好一个处理服务器数据的函数，然后生成一个 script 元素，src 指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器。

跨域站点返回一段调用该函数的脚本，当客户端接收到脚本后就会运行事先准备的函数，从而实现跨域获取数据。

JSONP 实现简单、兼容性好，但缺点也很明显，它只支持 get 请求，同时也有安全性问题，并且对服务器端代码侵入性比较强。

2.  使用 cors

在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。

cors 协议已被各种主流浏览器支持，它安全性高，同时也不会侵入服务器代码，是目前最主流的跨域方式

除此之外，远古时期的跨域处理还包括 iframe、form 等，由于它们缺陷非常明显，故很少使用了。

---

### 介绍下 HTTPS 中间人攻击

**口语化** - 中间人攻击过程如下：

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密 hash 值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息。

**详细版**- HTTPS 中间人攻击的基本流程是：

1. 攻击者在客户端和服务器之间部署一个中间代理服务器。
2. 客户端以为它正在和服务器直接通信，但实际上客户端和服务器之间的通信是被中间人攻击者劫持和监控的。
3. 攻击者可以读取、修改和重组从客户端发出和服务器接收的数据。
4. 服务器也以为它正在和客户端直接通信，实际上服务器收发的数据也是经过中间人攻击者的监控和修改。
5. 攻击者可以获取重要信息如账号、密码，或者修改数据导致错误信息，破坏通信等。

防范方法： **服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性**

---

### 介绍下前端加密的常见场景和方法

首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解。

使用场景：

1. 存储敏感数据：如用户密码、支付信息等需要加密存储，防止被泄露。
2. 通信安全：如 HTTPS 通信需要加密，防止被窃听。
3. 数字签名：用于验证数据完整性，防止被篡改。
4. 隐私数据处理：一些隐私数据需要在前端加密后上报，防止未加密数据外泄。

加密方法:

1. 对称加密：如 AES，加密和解密使用同一密钥，用于数据的加密存储和解密使用。
2. 非对称加密：如 RSA，使用公钥加密,私钥解密，用于数据的加密和数字签名。
3. Hash 函数：如 MD5，SHA 等，无法解密，用于验证数据完整性和存储用户名或密码等。
4. 数字签名：使用非对称加密算法生成，用于验证数据发送者身份和数据完整性。

### 说下单点登录

SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。

**具体流程是**：
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。

**具体流程是**：

-   用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数
-   sso 认证中心发现用户未登录，将用户引导至登录页面
-   用户输入用户名密码提交登录申请
-   sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌
-   sso 认证中心带着令牌跳转会最初的请求地址（系统 1）
-   系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效
-   sso 认证中心校验令牌，返回有效，注册系统 1
-   系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
-   用户访问系统 2 的受保护资源
-   系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数
-   sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌
-   系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效
-   sso 认证中心校验令牌，返回有效，注册系统 2
-   系统 2 使用该令牌创建与用户的局部会话，返回受保护资源

### 列举优化网络性能方法

1.  优化打包体积
    利用一些工具压缩、混淆最终打包代码，减少包体积

2.  多目标打包
    利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积

3.  压缩
    现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的

4.  CDN
    利用 CDN 可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的 CDN 资源，这样可以实现跨越站点的缓存

5.  缓存
    对于除 HTML 外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件 hash 值来置换缓存

6.  http2
    开启 http2 后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据

7.  雪碧图
    对于不使用 HTTP2 的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的

8.  defer、async
    通过 defer 和 async 属性，可以让页面尽早加载 js 文件

9.  prefetch、preload
    通过 prefetch 属性，可以让页面在空闲时预先下载其他页面可能要用到的资源。
    通过 preload 属性，可以让页面预先下载本页面可能要用到的资源。

10. 多个静态资源域
    对于不使用 HTTP2 的场景，将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个 TCP 连接，并行下载

###   什么是 DNS 域名解析？

DNS 域名解析是指把域名解析成 IP 地址的过程。

在具体的实现上，域名解析是由多个层级的服务器共同完成的。在查询域名时，客户端会先检查自身的 DNS 映射表，若找不到解析记录，则使用用户配置的 DNS 服务器，若目标 DNS 服务器中找不到记录，则继续往上一个层级寻找，直到到达根域名服务器，根域名服务器会根据域名的类型，将解析任务分发到对应的子域名服务器依次查找，直到找到解析记录为止。
